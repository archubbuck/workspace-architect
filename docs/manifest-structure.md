# Assets Manifest Structure

## Overview

The `assets-manifest.json` file is the central registry of all assets in the Workspace Architect package. As of version 2.0.0, the manifest uses a nested structure to organize assets by type.

## Structure

### Version 2.0.0+ (Current)

The manifest now uses a nested object structure where assets are grouped by type:

```json
{
  "version": "2.0.0",
  "generatedAt": "2026-01-09T23:32:12.814Z",
  "assets": {
    "agents": {
      "4.1-Beast": {
        "path": "assets/agents/4.1-Beast.agent.md",
        "description": "GPT 4.1 as a top-notch coding agent.",
        "title": "4.1-Beast",
        "type": "agents"
      },
      "api-architect": {
        "path": "assets/agents/api-architect.agent.md",
        "description": "Your role is that of an API architect...",
        "title": "api-architect",
        "type": "agents"
      }
    },
    "instructions": {
      "a11y": {
        "path": "assets/instructions/a11y.instructions.md",
        "description": "Guidance for creating more accessible code",
        "title": "a11y",
        "type": "instructions"
      }
    },
    "prompts": { ... },
    "collections": { ... },
    "skills": { ... }
  }
}
```

### Version 1.x.x (Legacy)

The previous flat structure used colon-separated keys:

```json
{
  "version": "1.1.0",
  "generatedAt": "2026-01-08T19:07:25.235Z",
  "assets": {
    "agents:4.1-Beast": {
      "path": "assets/agents/4.1-Beast.agent.md",
      "description": "GPT 4.1 as a top-notch coding agent.",
      "title": "4.1-Beast",
      "type": "agents"
    },
    "agents:api-architect": {
      "path": "assets/agents/api-architect.agent.md",
      "description": "Your role is that of an API architect...",
      "title": "api-architect",
      "type": "agents"
    }
  }
}
```

## Asset Types

The manifest organizes assets into five types:

1. **agents**: Custom GitHub Copilot agents with specialized roles
2. **instructions**: Context instructions for specific technologies or patterns
3. **prompts**: Reusable prompt templates
4. **collections**: Curated sets of related assets
5. **skills**: Claude Skills (multi-file directory-based assets)

## Asset Properties

Each asset in the manifest contains:

- `path`: Relative path to the asset file(s)
- `description`: Brief description of the asset's purpose
- `title`: Display name for the asset
- `type`: The asset type (agents, instructions, prompts, collections, skills)
- `items`: (Collections only) Array of asset IDs included in the collection
- `files`: (Skills only) Array of relative file paths within the skill directory
- `metadata`: (Skills only) Additional metadata like version and license

## Backward Compatibility

While collections still reference assets using the `type:name` format (e.g., `"agents:4.1-Beast"`), the CLI internally converts these to nested lookups. This maintains compatibility with existing collection files while leveraging the improved manifest structure.

## Generation

The manifest is automatically generated by the `scripts/generate-manifest.js` script, which:

1. Scans the `assets/` directory for all asset types
2. Parses frontmatter metadata from markdown files
3. Reads collection JSON files for items lists
4. Processes skill directories and their files
5. Generates the nested structure

To regenerate the manifest:

```bash
npm run generate-manifest
```

## Usage in CLI

The CLI (`bin/cli.js`) reads the manifest to:

- List available assets by type
- Download individual assets or entire collections
- Resolve asset paths for fetching from GitHub

Example lookups:

```javascript
// Get an agent
const agent = manifest.assets.agents['4.1-Beast'];

// Get an instruction
const instruction = manifest.assets.instructions['a11y'];

// Get all prompts
const allPrompts = Object.keys(manifest.assets.prompts);
```

## Migration Guide

If you're consuming the manifest programmatically:

**Before (v1.x.x):**
```javascript
const asset = manifest.assets['agents:4.1-Beast'];
```

**After (v2.0.0+):**
```javascript
const [type, name] = 'agents:4.1-Beast'.split(':');
const asset = manifest.assets[type][name];
```

## Benefits of Nested Structure

1. **Better Organization**: Assets are logically grouped by type
2. **Easier Navigation**: Type-level structure is more intuitive
3. **Improved Extensibility**: Adding new asset types is cleaner
4. **Simplified Validation**: Type-specific schemas are easier to apply
5. **Performance**: Direct object access instead of filtering
